# 实验三 基于MATLAB的卷积码仿真及性能分析
## 1. 实验目的

本实验旨在通过MATLAB仿真实现卷积码的编码和译码过程，设计完整的数字通信系统模型，并比较有无卷积码编码的系统在不同信噪比条件下的性能差异。通过本实验，加深对卷积码原理的理解，掌握卷积码在实际通信系统中的应用，学习通信系统性能分析的方法。

## 2. 卷积码编译码的基本原理

### 2.1 卷积码基本概念

卷积码是一种连续的编码方式，它与分组码不同，编码过程具有记忆性。卷积码的基本参数包括：

- **码率 R = k/n**：表示输入k个信息比特，输出n个编码比特。
- **约束长度 K**：表示影响当前输出的输入比特数量，K-1为移位寄存器的级数。
- **生成多项式**：描述输入与输出之间的关系，通常用二进制或八进制表示。

### 2.2 卷积码编码原理

卷积码编码器由移位寄存器、模2加法器和连接它们的线路组成。编码过程可以理解为信息序列与编码器的脉冲响应序列进行卷积操作。当一个信息比特输入到编码器时，它会影响后续多个输出比特，这种影响由编码器的结构（即生成多项式）决定。

对于码率为1/2的卷积码，每输入1个信息比特，输出2个编码比特。输出比特是由当前输入比特和移位寄存器中的历史比特共同决定的。生成多项式描述了这种依赖关系。

卷积编码器的状态可以用网格图(Trellis)来表示，网格图展示了输入、状态转移和相应的输出之间的关系。

### 2.3 卷积码译码原理

卷积码最常用的译码算法是维特比(Viterbi)算法，它是一种最大似然译码算法。维特比算法在网格图上搜索一条与接收序列最相似的路径，从而恢复出最可能的信息序列。

维特比算法的核心步骤包括：

1. **分支度量计算**：计算每个时刻状态转移的度量（通常是汉明距离或欧氏距离）。
2. **路径度量更新**：对于每个状态，选择具有最小累积度量的路径作为到达该状态的幸存路径。
3. **幸存路径选择**：保留到达每个状态的最佳路径，丢弃其他路径。
4. **回溯**：从终点往回追踪，获得最佳路径上的状态序列，从而确定原始信息比特。

维特比算法的复杂度与状态数成正比，而状态数随约束长度指数增长（2^(K-1)），因此较长的约束长度会导致更高的译码复杂度。

## 3. 系统设计与实现

### 3.1 系统模型

本实验设计了完整的数字通信系统模型，包括：

系统包括以下模块：
- 信息源（随机生成二进制比特）
- 编码器（卷积编码）
- 调制器（BPSK调制）
- 信道（AWGN噪声信道）
- 解调器（BPSK解调）
- 译码器（维特比译码）

同时，为了进行性能比较，我们还实现了不使用卷积码编码的系统路径。

### 3.2 卷积编码器实现

本实验中，卷积编码器采用MATLAB通信工具箱的内置函数实现。
- **约束长度 K**: 3
- **生成多项式 (八进制)**: g0 = 7, g1 = 5
- **码率 R**: 1/2

网格结构通过 `poly2trellis(K, [7 5])` 函数定义。
实际的编码操作由 `convenc` 函数完成，该函数根据定义的网格结构对输入信息比特进行编码，并自动处理尾比特以确保网格终止。

```matlab
% 主要的编码步骤示例:
K = 3;
generator_polynomials_octal = [7 5];
trellis_structure = poly2trellis(K, generator_polynomials_octal);
% info_bits 为输入信息比特序列 (列向量)
coded_bits = convenc(info_bits, trellis_structure); 
```

### 3.3 维特比译码器实现

维特比译码器同样采用MATLAB通信工具箱的 `vitdec` 函数实现。该函数基于定义的网格结构，对接收到的（可能含有错误的）编码比特序列进行最大似然译码。

关键的译码参数设置包括：
- **操作模式**: 'term' (对应于终止网格的编码)
- **判决类型**: 'hard' (硬判决译码)
- **回溯深度**: 通常设置为约束长度的5倍 (即 `5*K`)

```matlab
% 主要的译码步骤示例:
% demodulated_bits_hard_coded 为硬判决解调后的比特序列 (行向量)
% trellis_structure 为先前定义的网格
% traceback_depth 为回溯深度
decoded_info_bits = vitdec(demodulated_bits_hard_coded.', trellis_structure, traceback_depth, 'term', 'hard');
```

### 3.4 BPSK调制解调实现

BPSK调制和解调也使用MATLAB通信工具箱的函数：
- **BPSK调制器**: `pskmod` 函数。输入比特0和1被映射到相应的相位（例如，0映射为+1，1映射为-1）。
  ```matlab
  % modulated_symbols = pskmod(bits, 2, 0, 'gray'); 
  % 其中 bits 为0或1的输入，2表示BPSK (M=2)
  ```
- **BPSK解调器**: `pskdemod` 函数。根据接收信号的相位（对于硬判决，即符号的正负）判决恢复出比特0或1。
  ```matlab
  % demodulated_bits = pskdemod(received_symbols, 2, 0, 'gray');
  ```

### 3.5 完整通信系统实现

完整的通信系统仿真代码在 `communication_system_simulation.m` 文件中实现。该脚本现在完全基于MATLAB通信工具箱的内置函数，集成了上述编码、译码、调制、解调模块。
此外，AWGN信道噪声通过 `awgn` 函数添加，误比特率（BER）则通过 `biterr` 函数计算。

系统实现了两条路径：
1. **编码路径**：信息比特 → `convenc` → `pskmod` → `awgn` → `pskdemod` → `vitdec` → `biterr`
2. **未编码路径**：信息比特 → `pskmod` → `awgn` → `pskdemod` → `biterr`

通过比较这两条路径在不同Eb/N0下的误比特率性能，我们可以评估卷积码的编码增益。

## 4. 实验仿真与结果分析

### 4.1 仿真参数设置

本实验（使用MATLAB内置函数版本）采用以下参数进行仿真：

- 卷积码参数：码率R=1/2，约束长度K=3，生成多项式g0=7 (八进制)，g1=5 (八进制)
- 调制方式：BPSK
- 信道模型：AWGN信道
- 信噪比范围：Eb/N0 = 0:1:10 dB
- 每个信噪比点传输的信息比特数：1,000,000比特
- 每个信噪比点的迭代次数：1次 (由于每个点的信息比特数已足够大)

### 4.2 仿真结果与分析

运行基于MATLAB内置函数的仿真脚本后，我们得到了编码系统和未编码系统在不同Eb/N0下的误比特率曲线，如下图所示。

![BER性能曲线](ber_performance_soft_hard_cont.png) 


从仿真结果中可以普遍观察到以下几点：

1. **编码增益**：在相同的Eb/N0条件下，使用卷积码的系统通常具有低于未编码系统的误比特率。这表明卷积码能够有效提高系统的抗噪声能力。

2. **性能改善随信噪比变化**：随着Eb/N0的增加，编码系统的性能改善更为显著。

3. **理论与实践比较**：未编码BPSK的仿真曲线应与理论曲线非常接近，这有助于验证仿真平台的正确性。

4. **编码性能趋势**：在高信噪比区域，编码系统的BER曲线通常比未编码系统降低更快，表明卷积码在高信噪比下具有更好的纠错能力。

具体的编码增益数值和曲线行为细节，请参考运行新仿真脚本后得到的实际图形和数据。

## 5. 结论与思考

通过本次实验，我们得出以下结论：

1. 卷积码是一种有效的前向纠错码，通过引入冗余可以显著提高通信系统的可靠性。

2. 维特比算法是卷积码译码的高效方法，它在卷积编码的译码过程中具有最优性能。

3. 卷积码在不同信噪比区域的性能增益不同，在中低信噪比区域具有较大的编码增益。

4. 在设计实际系统时，需要权衡码率、约束长度和复杂度之间的关系，根据实际需求选择合适的卷积码参数。

思考与扩展：

1. 如果增加约束长度K，系统性能会进一步提高，但译码复杂度会呈指数增长。

2. 在实际系统中，可以考虑使用打孔卷积码来提高码率，或者结合交织技术来改善在突发噪声条件下的性能。

3. 软判决译码（使用接收信号的软信息）比硬判决译码具有更好的性能，但需要更复杂的译码器实现。

4. 现代通信系统常使用Turbo码或LDPC码等更先进的编码方案，它们具有接近香农极限的性能，但实现复杂度也更高。
